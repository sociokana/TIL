## Kubernetes - Core Concepts

### 클러스터 아키텍쳐
- 마스터 노드: 노드들을 관리, 계획, 스케줄, 모니터한다
	- ETCD Cluster
		- ETCD는 키-밸루 포맷으로 정보를 저장해두는 데이터베이스. 
	- kube-scheduler
		- 컨테이너를 배치할 올바른 node를 선택함. 컨테이너의 리소스 요구사항, 워커 노드의 capacity, 다른 정책 등을 참고. 
	- 컨트롤러들
		- Replication-Controller: 올바른 수의 컨테이너가 매 순간 작동하고 있는지를 관리. 
		- Node-Controller: 
		- Controller-Manager
	- kube-apiserver 
		- 모든 오퍼레이션들의 통신을 관장함.
- 워커 노드: 컨테이너와 같은 어플리케이션을 호스트한다 
	- Container Runtime Engine
		- 모든 어플리케이션을 컨테이너에 격납될 수 있는 형태로 만들 필요가 있음. 
		- Docker 등등. 
	- kubelet
		- 클러스터 안의 각 노드에서 움직이는 agent. kube-apiserver의 명령을 받고 노드에서 컨터이너를 디플로이하거나 없애거나 함. 
	- Kube-proxy 
		- 클러스터 안의 서비스들간의 통신을 관리. 

### ETCD
#### ETCD란 무엇인가?
- a distributed reliable key-value store - 분산형 키-값 저장소 - that is simple, secure and fast. 

#### Key-Value Store란 무엇인가? 
- 데이터베이스는 전통적으로 Tabular/Relational 데이터베이스였음. 
- Key-Value 포맷은 기존의 이런 형식을 완전히 대체하기 위한 것은 아님. 작은 정보들을 빠르게 불러오고 관리하기 위해 사용함. 

#### Install/Operate ETCD
``./etcd`` 포트 2379
``./etcdctl set key1 value1``
``./etdctl get key1``
``./etcdctl`` 모든 키 밸루 정보를 보여줌.

#### 쿠버네티스에 있어서 ETCD의 역할
- kubectl get 커맨드로 띄울 수 있는 모든 정보들은 ETCD 서버에서 오는 것. 
	- 노드
	- 팟
	- Configs
	- Secrets
	- Accounts
	- Roles
	- Bindings
	- Others
- 클러스터를 어떻게 셋업했느냐에 따라 ETCD가 디플로이되는 방식도 변화함. 
	- 처음부터 디플로이하는 것과 kubeadm을 통해 디플로이하는 방식. 
		- 처음부터 디플로이할 경우, ETCD 바이너리를 스스로 다운받아야 함. 
		- kubeadm을 통해 설치할 경우, 
			- ``kubectl get pod -n kube-system ``
- ETCD의 설정
	- advertised cloud url: ETCD가 듣는 주소. (기본 포트는 2379). 이 주소를 kube-apiserver 에서 etcd server에 접근할 때 사용해야 함. 
	- 


#### kube-apiserver
- kubectl 커맨드를 사용할 때 kubectl 유틸리티는 kube-apiserver에 연결함. kube-apiserver 는 리퀘스트를 인증하고 validate 함. 그리고 데이터를 etcd 클러스터에서 불러와서 요청받은 정보를 보여줌. 
- kubectl 커맨드를 사용하지 않고 post request를 보내서 api 를 직접 불러올 수도 있음. 

#### Kube Controller Manager
노드 컨트롤러: 지속적으로 노드의 상태를 확인하는 프로세스
1. 노드들의 상태를 기본적으로 5초마다 확인
2. 노드에서 heartbeat 가 도착하지 않으면 디폴트로 40초를 기다렸다가 not reachable 처리
3. 이후 디폴트로 5분동안 돌아오지 않으면 그 노드에 assign된 팟을 제거하고 다른 노드로 옮김.

레플리케이션 컨트롤러: 레플리카셋의 상태를 모니터링.
1. 팟이 죽으면 다른 걸 만듦. 

이 컨트롤러 외에도 Namespace-, Endpoint-, Service-Account-, 등등의 컨트롤러가 있음. 

이러한 노드들은 하나의 프로세스 - 즉 Kubernetes Controller Manager에 담김. 이를 인스톨하면 여러 컨트롤러들도 같이 인스톨됨. 


#### Scheduler
- 어떤 팟이 어떤 노드로 갈지를 정함 (정하기만 함. 실제로 팟을 그 노드에 만드는 건 kubelet의 역할)
- 스케줄러는 각각의 Pod을 보고 요구사항 등을 파악하여 최선의 노드를 찾음. 1. filter 2. rank. 방식은 커스터마이징할 수 있음. 

#### Kubelet 
- 노드를 진두지휘. 마스터 노드와 통신
- registers the node with the kubernetes cluster.
- 컨테이너를 로드하거나 팟을 만들라는 명령을 받으면 컨테이너 런타임 (docker 등) 엔진에게 해당 이미지를 가져오고 인스턴스를 실행할 것을 요청함. 
- Pod 과 컨테이너의 상태를 모니터링하고 apiserver에 보고. 

#### Kube Proxy
- 모든 팟은 다른 팟에 연결할 수 있음. 
- Pod Network는 내부적인 가상 네트워크. 이러한 네트워크를 디플로이하는 법은 많음. 
- 팟끼리 통신을 하게 하고 싶을 때는 서비스를 이용함.
- 그런데 서비스는 어떻게 작동하는 것일까? 
- 서비스는 어디까지나 가상적 component. 접속 가능한 인터페이스나 listening process가 존재하지 않음. 그렇다면 어떻게 서비스를 통해 다른 팟에 연결하는 걸까? 
- kube-proxy 를 사용. 쿠버네티스의 각 노드에서 실행되는 프로세스. 새 서비스가 만들어지면 적당한 룰을 각 노드에서 만들어서 해당 서비스가 백엔드 팟들에게 트래픽을 전송할 수 있도록 만듦. 
- IPTABLE rules. 

#### Namespaces 
- 여지까지 만들었던 pod, deployment, services 들은 어떠한 하나의 namespace에 속해 있다. 
- 처음부터 존재하는 네임스페이스들: default, kube-system, kube-public.  
- kube-system: 실수로 삭제하거나 에딧하게 하지 않기 위해 분리해둔 것들의 네임스페이스.
- kube-public: 모든 유저들이 사용 가능한 리소스들이 만들어지는 곳. 
- 작은 환경에서는 default로 충분하지만 커지면 자신의 namespace를 만들 필요가 생김. dev, production 등등으로. 
- 각각의 네임스페이스는 각자의 policy가 있고 각자가 사용 가능한 리소스를 설정해놓을 수 있음. 
- 네임스페이스에 들어 있는 요소에 대해 접근 가능한 dns가 자동으로 만들어지고 이를 통해 다른 네임스페이스의 요소에 접근할 수 있음. 
	- ``Service Name.Namespace.Service.domain``
- kubectl get pods --namespace=kube-system 
	- 아무것도 안 적으면 default 안에 있는 것들만 보임. 
- yaml 파일을 만들 때 metadata: 안에 namespace: 를 만들 수가 있음. 
- yaml 파일을 통해 namespace를 작성하기

```
apiVersion: v1
kind: Namespace
metadata:
	name: hoge 
```

- 혹은 커맨드로 작성하기
``kubectl create namespace hoge``

- 기본 네임스페이스를 default 에서 다른 것으로 바꾸기 
``kubectl config set-context $(kubectl config current-context) --namespace=dev`` 

- 모든 네임스페이스를 보기
``kubectl get pods --all-namespaces``

- 각 네임스페이스에 대한 리소스 quota를 설정하기

```
apiVersion: v1
kind: ResourceQuota
metadata: 
	name: hoge-quota
	namespace: hoge
spec:
	hard:
		pods: "10"
		requests.cpu: "4"
		requests.memory: 5Gi
		limits.cpu: "10"
		limits.memory: 10Gi
```

### CKA 시험 볼 때의 팁
- 터미널에서 yaml 파일을 하나하나 만들고 있을 시간이 없다. 그렇다면? 
- 이를테면 deployment 의 yaml 파일을 만들고 싶다고 치자. 
- ``kubectl create deployment nginx --image=nginx --replicas=3 --dry-run=client -o yaml > test.yaml``
- 이렇게 하면 이미지는 nginx, replicas는 3인 nginx라는 이름의 디플로이먼트 yaml file (``test.yaml``) 이 만들어진다. 이걸 편집하거나 하는 편이 빠르다. 

### 출처 
https://www.udemy.com/course/certified-kubernetes-administrator-with-practice-tests/
