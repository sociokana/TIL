## 쿠버네티스 

### Services

- 서비스는 어플리케이션 안팎의 요소들을 이어주는 역할을 함. 어플리케이션끼리 통신할 수 있게 해주거나, 프론트엔드를 노드 바깥에 존재하는 엔드유저에게 연결되게 해주거나, 백엔드를 DB에 연결해주거나 하는 등. 
- 몇 가지 종류의 서비스를 만들 수 있지만, 공통된 건 다른 애플리케이션 혹은 외부의 엔드 유저로부터 접근할 필요가 있을 때, 즉 뭔가의 접속 target이 될 필요가 있을 때만 서비스를 만들어야 한다는 것. 

### NodePort
- Node 에는 IP 주소가 부여되고, 그 안에 있는 Pod들에게도 하나씩 내부적으로 IP 주소가 부여된다. 
	- Pod을 만들 때 spec: > ports: > - containerPort: 를 지정할 수가 있음. 
- NodePort가 존재하지 않을 경우, 바깥에 있는 유저가 안에 있는 팟의 어플리케이션에 접근하기 위해서는 일단 Node에 ssh 등을 통해 Node 내부에 접속한 후 그 안에서 내부적으로 원하는 팟에 연결할 필요가 있다. 그러나 이건 이상적인 상황이 아니다.
- 그럼 바깥에 있는 엔드유저와 안에 있는 팟을 직접 연결해주는 건 무엇일까? 그게 바로 서비스 중 하나인 NodePort. 
- 노드의 포트로부터 들어오는 요청을 받아서 팟에 연결해준다. 
- 여기서 중요한 포트는 세 가지.
	- NodePort: 밖에서 노드로 들어오는 포트. 30000-32767까지의 범위를 기본으로 가진다. 
	- Port: 서비스의 포트. 서비스 기준이기 때문에 이 포트에는 전치사가 붙지 않았다. 서비스는 서비스대로 IP를 가지는데, 이를 ClusterIP라고 부름. 
	- TargetPort: Pod의 포트. 이 포트로 가는 게 목적이기 때문에. 

NodePort 서비스의 yaml 파일은 다음과 같이 생겼다. 

```
apiVersion: v1
kind: Service
metadata: 
	name: hogehogeService
spec: 
	type: NodePort
	ports:
	 - targetPort: 80 # 쓰지 않으면 Port와 동일한 것으로 처리함.
	   port: 80
	   nodePort: 30008 # 쓰지 않으면 자동적으로 범위 내에서 지정한다. 
	selector: 
		label-test: lable-name
```

- 여러 개의 Pod 이 존재할 경우 같은 label을 붙여줌을 통해 서비스가 자동적으로 트래픽을 보냄. 
- 여러 개의 Node가 존재하고 그 안에 Pod들이 존재할 경우? 쿠버네티스는 자동으로 여러 개의 Node에 걸친 서비스를 만들어주고 어떤 노드의 IP주소로 들어와도 포트 번호만 매치되면 서비스는 트래픽을 타겟으로 보냄. 
- minikube를 사용할 경우
``minikube service servicename --url`` 을 통해 외부에서 접근 가능한 IP주소를 알아낼 수 있음. 

``kubectl create -f service-definition.yaml``


#### ClusterIP
- 웹 어플리케이션은 보통 여러 개의 tier 로 구분해볼 수 있다. 프론트엔드, 백엔드, DB 서버 등등. 
- 이 어플리케이션이 각자와 통신하기 위해서는 어떻게 할까? Pod에 개별적으로 ip주소가 지정되기는 하지만 이는 static 한 게 아니기 때문에 이걸 기준으로 통신할 수는 없음.
- ClusterIP는 팟들을 클러스터링해서 액세스할 수 있는 단일한 인터페이스를 제공해줌. 
```
apiVersion: v1
kind: Service
metadata: 
	name: back-end
spec: 
	type: ClusterIP # 디폴트 타입이므로 쓰지 않아도 됨
	ports:
	 - targetPort: 80 
	   port: 80
	selector: 
		label-test: lable-name
```

#### LoadBalancer 
- 여러 개의 엔드유저용 노드가 있을 경우, 서비스는 하나여도 접근할 수 있는 IP는 여러 개가 되어버림. 
- 방법 중 하나는 로드밸런서용 VM을 만들고 외부 로드밸런스를 만들어놓는 것. 
- 하지만 AWS, GCP, Azure 같은 클라우드 플랫폼은 네이티브 로드밸런서를 알아서 제공해줌. 
- 만약 이를 지원하지 않는 플랫폼의 경우 LoadBalancer 를 지정해도 작동은 NodePort랑 똑같이 작동함. 
```
apiVersion: v1
kind: Service
metadata: 
	name: LB-Service
spec: 
	type: LoadBalancer
	ports:
	 - targetPort: 80 
	   port: 80
	   nodePort: 30008 
	selector: 
		label-test: lable-name
```


### Microservices Architecture 
- 5개의 작은 앱으로 이루어진 앱 만들기 demo 
- 

### 출처
[Kubernetes for the Absolute Beginners - Hands-on](https://www.udemy.com/course/learn-kubernetes/)